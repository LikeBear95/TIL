## 비트 연산자
|연산자|연산자의 기능|
|:---:|:---|
|&|비트 단위로 AND 연산을 한다. <br> 예) num1 & num2|
|\||비트 단위로 OR 연산을 한다. <br> 예) num1 \| num2|
|^|비트 단위로 XOR 연산을 한다. (같으면 0 다르면 1) <br> 예) num1 ^ num2|
|~|단항 연산자로서 피연산자의 모든 비트를 반전시킨다. <br> 예) ~num|
|<<|피연산자의 비트 열을 왼쪽으로 이동시킨다. <br> 예) num << 2|
|>>|피연산자의 비트 열을 오른쪽으로 이동시킨다. <br> 예) num >> 2|

1) 부호 절대값 방식
2) 1의 보수
3) 2의 보수

컴퓨터는 0,1과 2진수로만 이루어져있다

-> 음수는 어떻게 표현하지?



1.부호절대값

2.1의보수

3.2의보수



1,2,3의 공통점 (최상위비트 MSB) -> 1이면 음수, 0이면 양수





부호절대값(8bit)

```
10진수 10 (2진수)

0000 1010

[1]000 1010
```

장점) "사람이" 보기,쓰기 편하다



단점)1.연산이 이상한값

7-4

```
0000 0111 (+7)
0000 0100 (+4)
1000 0100 (-4)

 0000 0111 (+7)
+1000 0100 (-4)
 1000   1011 (-11)????
```

단점2) 뺄셈을 하는데 뺄셈로직이 필요하다

단점3) 표현할 수 있는 숫자가 적어진다

```
0000 0000 8비트로 표현할수 있는 가장 큰수?255
1111 1111

0 ~ 255까지 (256개)
[0]111 1111   (128) -127 ~ + 127
+         1
-----------
[1]000 0000

[1]111 1111   (128) -127 ~ + 127
+         1
-----------
[0]000 0000

```



---

2. 1의 보수

   보수란? (보충하는 수)

   10진수 3 -> 7 (4)

   10진수 654-> 9진법을 만들려면 보수가 몇이필요하냐?

   345



10진수 10 -> 2진수로 바꿔라

1111 1111

-

0000 1010 -> 이친구의 1의 보수는?

1111 0101 -> 1의 보수로 표현한 -10



7-4 -> 7 + (-4)

```
0000 0111 (+7)
0000 0100 (+4)
[1]111 1011 (-4)

 [0]000 0111 (+7)
+[1]111 1011 (-4)
-------------------
????1 [0]000 0010 -> +2
     +[0]000 0001
-------------------
[0]000 0011 -> +3
```

1의 보수 장점) 뺄셈 연산을 덧셈으로 하기편하다

보수화(뒤집는다) 만 이해하면 직관적으로 계산하기 쉽다



1의 보수 단점)양수 0과 음수0이 존재한다

```7
[0]111 1111 -> +127
[0]000 0000 -> +0
[1]000 0000 -> -0
[1]111 1111 -> 127
```





3) **2의보수**

2의 보수란? 1의보수 + 1



```
456(10진수) -> 6의보수? 210
            -> 7의보수? 321
            
10(10진수) -> 1010(4bit) 
          ->  0101(1의보수)
          -> 0101 + 0001 -> 0110(2의보수)
         
```



```
기존의 1의 보수 방식 4bit를 가지고 표현할 수 있는수

[0]111 -> +7(1의보수) -> [1]000(2의 보수화) -> -8
                         0111(+7+1 8)
[0]000 -> +0(1의보수) -> +1
[1]000 -> -0(1의보수) -> -1
[1]111 -> -7(1의보수) -> -6
+0001 

           
```
